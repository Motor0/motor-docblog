## PS

### 1. `ps` 是干什么的？

- **一句话**：`ps`（process status）就是“看当前有哪些进程在跑”。
- 你可以把它理解成 **Linux 的任务管理器**里“进程列表”的命令行版本。

------

### 2. 为什么看进程需要 `ps`？

场景举例：

- 想知道某个程序有没有跑（比如 `mysql`、`nginx`）。
- 想知道某个进程是哪个用户启动的，PID 是多少。
- 想确认后台脚本挂没挂。
- 想排查一个程序卡住时的状态。

------

### 3. `ps` 常见用法分类

> **注意**：不同系统（Linux vs BSD/Unix）选项习惯不同，有三种风格：

- **Unix 风格**：选项带 `-` （如 `ps -ef`）
- **BSD 风格**：选项不带 `-` （如 `ps aux`）
- **GNU 风格**：长选项 `--`（如 `ps --forest`）

所以你常见到的 `ps -ef` 和 `ps aux` 都对，但格式稍不同。

------

### 4. 最常见的几个命令

#### （1）只看自己当前终端下的进程

```bash
ps
```

输出大概像：

```
  PID TTY          TIME CMD
 2345 pts/1    00:00:00 bash
 5678 pts/1    00:00:00 ps
```

- `PID`：进程号
- `TTY`：进程所在的终端（本例是 `/dev/pts/1`）
- `TIME`：累计的 CPU 时间
- `CMD`：命令名

------

#### （2）查看所有进程（全系统）

```bash
ps -ef
```

解释：

- `-e` = every（所有进程）
- `-f` = full format（显示完整格式）

输出示例：

```
UID   PID  PPID  C STIME TTY      TIME CMD
root     1     0  0 Aug24 ?        00:00:01 systemd
user  1234  1200  0 01:22 pts/0    00:00:00 bash
user  5678  1234  0 01:23 pts/0    00:00:00 python app.py
```

字段含义：

- **UID**：哪个用户启动的进程
- **PID**：进程号（唯一标识进程）
- **PPID**：父进程号（谁启动的它）
- **C**：CPU 使用率
- **STIME**：进程启动时间
- **TTY**：在哪个终端启动的；`?` 代表没有（守护进程、后台服务）
- **CMD**：执行的命令

------

#### （3）BSD 风格（更常见于网上教程）

```bash
ps aux
```

- `a` = all，所有用户的进程
- `u` = user，显示用户信息
- `x` = 没有控制终端的进程也显示

输出示例：

```
USER   PID %CPU %MEM    VSZ   RSS TTY   STAT START   TIME COMMAND
root     1  0.0  0.1 167280  9260 ?     Ss   Aug24   0:01 /sbin/init
user  1234  0.0  0.2 273408 18500 pts/0 Ss   01:22   0:00 -bash
user  5678  1.2  1.5 743232 62500 pts/0 Sl   01:23   0:10 python app.py
```

字段含义：

- **%CPU**：CPU 占用百分比
- **%MEM**：内存占用百分比
- **VSZ**：虚拟内存大小（KB）
- **RSS**：实际占用的物理内存（KB）
- **STAT**：进程状态（见下一节）
- **START**：进程启动时间
- **TIME**：消耗的 CPU 时间
- **COMMAND**：命令

------

### 5. 进程状态（STAT 字段）

常见字母：

- **R** → Running（正在运行）
- **S** → Sleeping（休眠，可被唤醒）
- **D** → Uninterruptible sleep（一般是 I/O 阻塞）
- **T** → Stopped（被暂停，比如 Ctrl+Z）
- **Z** → Zombie（僵尸进程，父进程没回收）
- **s** → 进程是会话首进程
- **+** → 前台进程组中的进程

示例：`Ss`

- `S` = 睡眠
- `s` = session leader（会话领导进程，比如 shell）

------

### 6. 进阶玩法

#### （1）树状查看进程

```bash
ps -ef --forest
```

会显示进程的父子关系树，直观查看谁启动了谁。

#### （2）筛选特定进程

```bash
ps -ef | grep nginx
ps aux | grep python
```

找某个进程的 PID。

#### （3）按用户过滤

```bash
ps -u root
```

#### （4）只看 PID、命令

```bash
ps -eo pid,cmd
```

#### （5）实时替代工具

其实 `ps` 是快照，只显示执行那一刻的情况。
 要实时监控，常用：

```bash
top
htop
```

------

#### 7. 小总结（口诀记忆）

- **`ps -ef`**：看全系统（Unix 风格，运维常用）。
- **`ps aux`**：看全系统（BSD 风格，很多教材用）。
- **`ps`**：只看当前终端里的自己。
- **加 `--forest`**：看树。
- **配合 `grep`**：查目标进程。

## lsof

- 全称：**list open files**
- 作用：列出“当前系统里有哪些进程打开了哪些文件”。

在 Linux 里，**一切皆文件**，所以不仅是 `.txt` 文件，网络端口、管道、设备都能看作“文件”。这就让 `lsof` 特别强大。

------

### 2. 为什么重要？

- 查某个端口被谁占用了
- 查某个文件被哪个进程锁住了
- 查某个用户/进程正在用哪些资源

------

#### 3. 常见用法（超实用）

#### (1) 看端口被谁占用

```bash
sudo lsof -i :80
```

谁在用 80 端口？常用于调试 Web 服务。

#### (2) 看所有网络连接

```bash
sudo lsof -i
```

类似 `netstat`，能显示 TCP/UDP 连接。

#### (3) 看某个文件被谁占用

```bash
lsof /path/to/file
```

如果你 `umount` 一个磁盘失败，可以用这个找出哪个进程还在用文件。

#### (4) 看某个进程打开了哪些文件

```bash
lsof -p 1234
```

`1234` 是进程 PID，可以看到它的文件、socket、库等。

#### (5) 配合用户

```bash
lsof -u username
```

查看某个用户打开的所有文件。

------

### 4. 输出怎么看？

一条典型的 `lsof` 输出：

```
COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
nginx    1234 root   6u  IPv4  12345      0t0  TCP *:80 (LISTEN)
```

- **COMMAND**：哪个程序
- **PID**：进程号
- **USER**：谁的进程
- **FD**：文件描述符（比如 `6u`，数字+权限，`u`表示读写）
- **TYPE**：文件类型（REG=普通文件，DIR=目录，IPv4=网络连接）
- **NAME**：文件/端口的名字（这里是 `*:80`）

## grep

作用：按模式（正则表达式）筛选文本行。

### 常用方式

- **基本用法**

  ```bash
  grep "hello" file.txt
  ```

- **忽略大小写：**

  ```
  grep -i "hello" file.txt
  ```

- **显示行号：**

  ```
  grep -n "hello" file.txt
  ```

- **显示不匹配的行（取反）：**

  ```
  grep -v "hello" file.txt
  ```

- **统计匹配次数：**

  ```
  grep -c "hello" file.txt
  ```

- **只输出匹配的关键字（而不是整行）：**

  ```
  grep -o "hello" file.txt
  ```

`grep` 的精髓：**一行一行筛选，找你想要的行。**

## sed —— 替换/编辑

**作用：流编辑器，按规则修改文本。**（可以看作“批量执行编辑命令”）

**默认是输出编辑后的内容，并没有真正的修改文件内容**

### 常用方式

- **替换：**

  ```
  sed 's/old/new/' file.txt
  ```

  每行只替换第一个 `old`。

  ```
  sed 's/old/new/g' file.txt
  ```

  每行替换所有 `old`。

- **直接修改文件（慎用）：**

  ```
  sed -i 's/old/new/g' file.txt
  ```

- **删除包含某个字符串的行：**

  ```
  sed '/badword/d' file.txt
  ```

- **打印指定行（类似 head/tail）：**

  ```
  sed -n '3p' file.txt   # 打印第 3 行
  sed -n '2,5p' file.txt # 打印第 2 到第 5 行
  ```

- **多条命令：**

  ```
  sed -e 's/foo/bar/g' -e '/test/d' file.txt
  ```

 `sed` 的精髓：**模式匹配 + 批量编辑（替换/删除/插入）**。

## sort-排序工具

```shell
sort [选项] [文件]
```

- 如果不指定文件，默认从标准输入读取（比如管道 `|` 传入的数据）
- 输出默认是排序后的结果，打印到标准输出（屏幕）
- 默认按“字典序”（ASCII码顺序）：数字 < 大写字母 < 小写字母 (默认升序)

### 选项

**`-n`**：按**数值**排序（而不是字典序）

`-r`：**逆序**（reverse）

`-k`：按**指定列**排序（Key）

- **示例：多列排序--先按第2列数值排序，再按第1列字典序排序**

  - `students.txt`：

    ```txt
    Alice 85
    Bob 92
    Charlie 85
    David 92
    ```

  - **命令**+**输出**

    ```bash
    sort -k2,2nr -k1,1 students.txt
    
    Bob 92
    David 92
    Alice 85
    Charlie 85
    ```

  - `-k2,2nr` → 第2列，数值，逆序（高分在前）

  - `-k1,1` → 第1列，字典序（同分时按名字排序）

  **拓展解释**

  > 1. **`-k2,2nr`**
  >    - 明确指定只使用**第 2 列**作为排序关键字（`2,2` 表示 "从第 2 列开始，到第 2 列结束"）
  >    - 排序时**仅考虑第 2 列的内容**，完全忽略其他列
  >    - 例如对 `a b c` 这样的行，只会用 `b` 来排序
  > 2. **`-k2nr`**
  >    - 简写形式，未指定字段结束位置，默认表示**从第 2 列开始到行尾的所有内容**作为排序关键字
  >    - 排序时会把第 2 列及之后的所有列合并为一个整体来比较
  >    - 例如对 `a b c` 这样的行，会用 `b c`（第 2 列 + 第 3 列）作为整体来排序

`-t`：指定**字段分隔符**

- 指定某个符号分割，然后获取某一列的值进行输出

`-u`：**去重**（只保留唯一行）

- → 先排序，然后相邻重复行只保留一个
- 类似 `uniq`，但 `uniq` 只能去重相邻行，`sort -u` 会全局去重！ 

`-f`：**忽略大小写**

`-b`：忽略字段**开头的空白**

- → 排序时忽略每行或每字段开头的空格/Tab

`-o`：**输出到文件**（可与输入文件相同）

