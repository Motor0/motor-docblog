# 系统分区

- **安装系统时最好最小化安装，需要什么软件安装什么软件**

- 以下是基本分区，往后有更高级的LVM分区（比较符合现在的LInux系统的分区方式）
- 安装系统时最好把 selinux 这个功能给关了（此功能能过于复杂，不好使用）

## 选择分区表

### MBR 分区表

​	**最大支持2.1TB的存储空间，每个硬盘只能有4个主分区，多出的分区基本上无法使用，后续出现了针对于MBR技术上的补丁：**

#### 主分区

- **每块硬盘最多4个**

#### 扩展分区

- **每块硬盘最多1个**
- **扩展分区 + 主分区**
- **扩展分区不能格式化**
- **扩展分区只能用于包含更多的逻辑分区**

#### 逻辑分区

- **逻辑分区可以格式化，可以写入数据**
- **逻辑分区每块硬盘，可以分10个以上**

### GPT 分区表

- **最大支持 9.4 ZB的硬盘**

- **理论上支持无限主分区，现系统最多支持 128 个主分区**

### 关于 分区表的选择

**（windows和linux不一样）**

1. 如果没有人为干预：
   - 自动检测系统硬盘，小于等于2TB的硬盘，自动选择MBR分区
   - 自动检测系统硬盘，大于等于3TB的硬盘，自动选择GPT分区
2. 有人为干预
   - 需要安装系统前决定好选择分区表
3. 删除分区注意事项
   - 安装时它是从前往后安装
   - 删除时它是从后往前删除

## 格式化

不是为了清空数据格式化，而是为了写入文件系统格式化（只不过附带上了清空数据）

### 文件系统

**Linux常见文件系统**

- **ext4**
- **Btrfs**
- **XFS**
- **swap**
- **iso9660**

**格式化原理**

- **Block：数据块（文件数据就是放在里面的）：默认大小4KB；Linux还支持 1KB，2KB**

  - 如果一个文件需要占用多个Block，那么他会尽量依次存储，但不是绝对的
  - 一个文件可以占用多个Block，但是一个 Block，只能保存一个文件的数据

- Inode：I 节点：大小 1288Byte：Inode号 + 相关时间 + 相关权限+数据保存位置

  > Inode也会占用磁盘空间，他不会占用Block块数据空间；INode是有总数量的，是可能被占满的，不能无限新建空文件
  >
  > 参考 git 版本控制管理的原理，差不多，索引指向文件数据........

- 超级快：保存的整块分区的信息

  - INode总数，多少占用，多少空闲；Block也一样，还有其他.....

**实际上**

> ​	格式化是对存储设备（如硬盘、U 盘、SD 卡等）进行初始化处理的过程，其核心目的是为存储设备建立一套套文件管理规则，使其能被操作系统识别并正常存储数据。具体原理可分为三个关键步骤：
>
> #### 1. 清除文件系统的元数据（而非直接删除文件内容）
>
> 存储设备中所有文件的管理依赖 “元数据”—— 这是记录文件关键信息的系统数据，包括：
>
> - 文件的存储位置（在磁盘的具体物理扇区地址）；
>
> - 文件的名称、大小、创建 / 修改时间；
>
> - 文件的目录结构（哪个文件属于哪个文件夹）。
>
>   格式化时，**不会逐个擦除文件的实际内容**（即存储在磁盘扇区中的 0 和 1 二进制数据），而是直接清除或标记这些元数据为 “无效”。 这意味着：操作系统会认为设备 “已空”，后续写入新文件时，会直接覆盖原文件所在的物理扇区（原文件内容才会被真正删除）。 这也是格式化后，若未写入新数据，可通过数据恢复工具找回原文件的原因 —— 原文件内容仍在，只是元数据被清除，系统 “找不到” 它们了。
>
> #### 2. 建立新的文件系统结构
>
> 操作系统需要一套统一的规则来管理文件（如如何存储、查找、读取文件），这套规则就是 “文件系统”（如 NTFS、FAT32、Ext4 等）。
> 格式化的核心操作是**在设备上创建新的文件系统结构**，包括：
>
> - 划分 “元数据区”：专门用于存储上述文件元数据的固定区域（如 FAT32 的 “文件分配表”、**Ext4 的 “inode 节点”**）；
>
> - 定义存储规则：如单个文件最大容量、文件名长度限制、权限控制方式（如 Linux 文件的读 / 写 / 执行权限）；
>
> - 建立索引机制：让系统能快速通过文件名定位到文件的物理存储位置（类似图书馆的索引目录）。
>
>   不同操作系统支持的文件系统不同（如 Windows 默认用 NTFS，Linux 常用 Ext4），格式化时选择的文件系统，决定了设备能被哪些系统识别、支持哪些功能。
>
> #### 3. 检测并标记坏块（仅完全格式化）
>
> 存储设备长期使用后，可能出现 “坏块”—— 即物理损坏的存储单元（无法正常读写数据）。格式化分为 “快速格式化” 和 “完全格式化”：
>
> - 快速格式化：仅执行前两步（清除元数据 + 建立文件系统），速度快；
> - 完全格式化：在快速格式化基础上，增加 “全盘扫描” 步骤，逐一检测设备的每个存储单元，将坏块标记为 “不可用”。
>   此后，操作系统会自动避开这些坏块存储数据，避免因写入坏块导致数据丢失或设备故障。
>
> ### 总结
>
> ​	格式化的本质是**为存储设备重建文件管理系统**：通过清除旧的元数据、建立新的文件系统规则、标记不可用的坏块（完全格式化），使设备能被操作系统正确识别和高效管理。
> ​	它不是简单的 “删除文件”，而是对设备进行的 “底层管理规则重置”，为后续数据存储提供基础框架。

## 分区设备文件

**Linux 下一切皆文件**

给分区指定设备文件，系统会自动识别定义名称

#### 关于硬件接口类型

**通过 `lsblk` 命令查看设备关联信息**

`lsblk` 可以显示存储设备的基本信息，结合 `-o` 参数指定输出字段，能快速定位接口相关线索：

```bash
lsblk -o NAME,TYPE,TRAN

# NAME：设备名称（如 sda）
# TYPE：设备类型（disk 表示物理磁盘）
# TRAN：传输协议（关键字段，直接对应接口类型）
```

- SATA 接口：500MB/s  主流硬盘盒老式SSD固态硬盘
- SCSI 接口： 200MB/s  
- USB 接口：xxx
- M.2 NVMe（PCIe）接口: 7000MB/s

### 设备文件名

- **/dev/hda1**

  - `/` 根目录

  - `/dev/` 放入的是系统设备文件名

  - **hda1**
    - hd：IDE接口硬盘 (133 MB/s 光驱和老式机械硬盘)
    - a:   第 2 块硬盘
    - 1：第一个分区

- **/dev/sda1**

  `/dev/sda6`：第一个SATA接口硬盘的第2个逻辑分区（加入它是sata类型的接口）

  - sd:

    > ​	`sd` 是 **SCSI Disk（SCSI 磁盘）** 的缩写，最初用于标识通过 SCSI 接口连接的存储设备（如早期的机械硬盘）。
    > 但随着 Linux 系统的发展，这一命名规则被**统一沿用**—— 无论是通过 SATA 接口（常见的机械硬盘 / 固态硬盘）、USB 接口（U 盘 / 移动硬盘）还是 NVMe 接口（部分高速固态硬盘）连接的存储设备，都会默认以 `sd` 开头命名（注：部分 NVMe 设备可能以 `nvme` 开头，如 `nvme0n1`，但 `sd` 仍是最普遍的标识）。
    >
    > ​	简单说：`sd` 是 Linux 给 “可挂载的块存储设备”（能存文件的硬件）分配的统一前缀，代表 “这是一个可用于存储数据的磁盘类设备”。

- **/dev/nvme0n1p1**

  - nvme：**M.2 NVMe接口**
  - 0：存储模块
  - n1：第一块硬盘
  - p1：第一个分区

## 挂载

**盘符：用户访问不同分区的入口**

**挂载点：用户访问不同分区的入口**

- 把分区设备文件名和以及建立的空目录连接起来的过程，是**挂载**

- 已经建立的空目录是**挂载点**

必须分区的地方

- **`/boot/分区`**：启动分区 （500M）即可

- **swap 分区：**交换分区（虚拟内存）内存的两倍（建议实验环境不超2G）
- **`/` 分区：**系统分区

数据分区：按照实际使用的情况，重新分区

- **/www** 	有需要可以进行一个网站目录的分区
- **/basckup**      备份分区
- **/mysql**    数据库分区



