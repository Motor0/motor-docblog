相关系统排查，分析，监控等常用的命令解析（除去基本的命令--ls,cd等）

- **ls -R**
  - 当与 `ls` 一起使用时，它告诉 `ls` 命令不仅列出指定目录的内容，还要**递归地进入每一个子目录**，列出所有子目录中的内容，一直持续到最底层。

### Here文档及Here字符串

#### 文档

> **适用场景：多行文本输入**

`	HERE` 文档的主要作用是：**方便地向命令或程序传递多行文本输入，而无需创建临时文件或使用复杂的引号嵌套。**

- 在没有 `HERE` 文档的情况下，如果你要向一个命令（如 `cat`、`mysql`、`mail`）传递多行内容，你可能会：

  - 用多个 `echo` 拼接
  - 把内容写到临时文件里再读取
  - 使用复杂的转义和引号

  而 `HERE` 文档让这一切变得**简洁、直观、可读性强**。

**对比**

```bash
echo "Hello, World!"
echo "This is line 2."
echo "User: $USER"
echo "Date: $(date)"
```

**here文档**

```bash
cat <<EOF
Hello, World!
This is line 2.
User: $USER
Date: $(date)
EOF
#优点
一次写完所有内容
支持变量替换
代码清晰，易修改
```

#### 字符串

> **适用场景：单行或简单多行字符串**

`<<<` 是 **Here String**（这里字符串）的语法，和 `<<`（Here Document）类似，但更简洁，用于将**单行字符串**作为输入传递给命令。

**`<<` 的作用是：把一个字符串（变量或表达式）当作“文件内容”传递给命令的标准输入（stdin），而不需要使用 `echo` + 管道。** 

**基本使用**

```bash
command <<< "字符串内容"

相当于 echo "字符串内容" | command
```

**例子：与read结合**

```bash
# 使用 <<<（推荐）
read a b <<< "hello world"
echo "a=$a, b=$b"  # 输出：a=hello, b=world

# 等价写法（使用管道）
echo "hello world" | read a b
```

### 查看文件内容

```shell
#将ping的内容输出到 log 文件中，在后台执行 &
ping baidu.com > pingLog.log &
#持续查看日志更新的内容，最新的20行
tail -fn 20 pingLog.log
```

查看文件日志常用：**tail -fn 10从尾部开始看十行 循环刷新**

```shell
cat #把文件内容全部打印到终端 
cat -n #加上行号 
more #展示当前页面一页 
enter#下一行 空格下一页 
more -n 2#每次打印出两行 
less #展示一页可以用上下键移动
less +/spring #从spring字符开始展示 
head #从头开始看 
tail #从尾部查看

wc -l filename #读取总行数
```

#### wc

还有 `-w`,统计单词数

**`wc -l` 不只是能统计普通文件的行数，它还可以统计：**

- 命令输出（通过管道）
- 标准输入（键盘输入或脚本输入）
- 目录列表
- 日志内容
- 进程信息
- 网络数据等

**只要是可以产生文本输出的内容，都可以用 `wc -l` 来统计“行数”。**

#####  详细说明 + 示例

###### 统计命令输出的行数（最常见）

```bash
ps aux | wc -l
```

统计当前系统运行的进程数量（每一行代表一个进程）。

######  统计某个关键词在日志中出现的次数

```bash
grep "error" /var/log/syslog | wc -l
```

统计 `/var/log/syslog` 中包含 `"error"` 的行数。

######  统计目录中的文件数量

```bash
ls | wc -l
```

列出当前目录下的所有文件和目录，并统计总行数（即数量）。

######  统计标准输入的行数（手动输入）

你可以直接运行：

```bash
wc -l
```

然后手动输入几行文字，最后按 `Ctrl+D` 结束输入：

```
hello
world
linux
<按下 Ctrl+D>
```

输出可能是：
```
3
```

表示你输入了 3 行。

###### 统计网络连接数量（配合 netstat 或 ss）

```bash
netstat -tuln | wc -l
```

或者使用较新的命令：

```bash
ss -tuln | wc -l
```

统计当前监听的 TCP/UDP 连接数。

######  统计用户登录情况

```bash
who | wc -l
```

统计当前登录到系统的用户数量。

---

######  统计压缩文件内容（结合 zcat）

```bash
zcat file.txt.gz | wc -l
```

统计 `.gz` 压缩文件中的行数（不解压）。

---

##### 注意事项

| 情况               | 说明                                                 |
| ------------------ | ---------------------------------------------------- |
| 文件没有以换行结尾 | `wc -l` 不会把最后一行算进去                         |
| 输入为空           | 返回 `0`                                             |
| 权限问题           | 如果读取受保护的文件可能会失败                       |
| 处理大文件时性能   | 对非常大的文件处理较慢，建议结合 `head`、`tail` 使用 |

> **`wc -l` 能统计任何标准输入流的行数，不仅限于文件。**  
> 包括：命令输出、键盘输入、管道传递、重定向输入等。

## at 定时任务调度

**`at` 命令是干什么的？**

简单说，`at` 命令的作用就是：

> **“请在未来的某个时间点，帮我运行一下我指定的命令。”**

比如：

- “请在晚上 11:30 帮我关机。”
- “请在明天下午 3 点运行一个备份脚本。”
- “请在 10 分钟后给我发一封提醒邮件。”

**使用方式**

**常用命令操作**

| 操作                 | 命令                                    | 说明                                                       |
| :------------------- | :-------------------------------------- | :--------------------------------------------------------- |
| **查看已安排的任务** | `atq` 或 `at -l`                        | 查看当前用户所有已计划但未执行的任务列表。                 |
| **删除一个任务**     | `atrm [任务ID]` 或 `at -r [任务ID]`     | 比如 `atq` 显示任务ID是 `1`，则用 `atrm 1` 删除它。        |
| **从文件读取命令**   | `at now + 1 hour -f /path/to/script.sh` | 把要执行的命令写在一个脚本文件里，让 `at` 去执行这个文件。 |

**最基本的用法**

```bash
at [时间] [日期]
```

- 然后你会进入一个特殊的输入模式，你可以在这里输入你想执行的命令，输入完后按 `Ctrl + D` 保存并退出。

**示例**

```bash
# 1. 输入命令
at now + 10 minutes

# 2. 系统会提示你输入要执行的命令
warning: commands will be executed using /bin/sh
at> echo "休息一下吧！" > /dev/tty1
at> <按 Ctrl + D>

# 3. 系统会显示作业已安排
job 1 at Sat Aug 24 16:45:00 2025
```

**说明：**

- `now + 10 minutes`：表示“从现在起10分钟后”。
- `echo "休息一下吧！" > /dev/tty1`：这条命令的意思是把“休息一下吧！”这个文字输出到终端1。`> /dev/tty1` 是为了让信息能显示在你的屏幕上（如果不加，`at` 默认会把输出发到你的邮箱）。
- `Ctrl + D`：表示输入结束。

#### 常用的时间写法（非常灵活）

`at` 命令理解很多种时间表达方式，你可以选择最方便的一种：

- **具体时间**：`at 23:30` (晚上11点半)
- **明天**：`at 10:00 tomorrow` (明天上午10点)
- **后天**：`at 10:00 + 2 days` 或 `at 10:00 2 days`
- **下个星期**：`at 9:00 next week`
- **指定日期**：`at 14:00 2025-08-25` (2025年8月25日下午2点)
- **几分钟/小时后**：`at now + 5 minutes` 或 `at now + 2 hours`

##### 重点

1. **工作目录和路径**：

   - `at` 任务执行时，会回到你**当初创建这个任务时所在的目录**。所以最好使用**绝对路径**，比如 `/home/yourname/myscript.sh`，而不是 `./myscript.sh`。

2. **输出问题**：

   - 如果你的命令有输出（比如 `ls`, `echo`），默认情况下 `at` 会尝试把输出结果通过 **邮件 (email)** 发给你。

   - 如果你没配置邮件系统，或者想直接在屏幕上看到，就需要像上面例子一样，重定向到终端，比如 `> /dev/tty1`（假设你在tty1登录）。

     > **关于邮件的问题**
     >
     > `at` 命令默认**确实会尝试**将任务的执行结果（标准输出和标准错误）通过邮件发送给任务的创建者。但“发到邮件上”是否成功，取决于两个关键因素：
     >
     > 1. **你的系统是否配置了邮件服务**（MTA, Mail Transfer Agent）。
     > 2. **你是否知道如何查看本地邮件**。
     >
     > ##### 如何确认 `at` 是否把结果发到了邮件？
     >
     > 你可以通过以下步骤来检查：
     >
     > ##### 方法一：直接查看本地用户的邮件（最直接）
     >
     > 在 Ubuntu/Linux 系统中，用户的本地邮件通常存储在 `/var/mail/用户名` 或 `/var/spool/mail/用户名` 文件中。
     >
     > ​	执行完任务后，可以输入 **`mail`**  命令
     >
     > - 如果 `mail` 命令可用，执行后会进入邮件查看界面。你应该能看到一封来自 `at` 的邮件，内容就是你 `echo` 和 `date` 命令的输出。**如果没有就只能根据提示安装工具了**
     >
     > - **查看邮件文件**（备选方法）： 你也可以直接查看邮件文件的内容：
     >
     >   ​	`$USER` 会自动替换为你的用户名。如果文件存在且有内容，就说明邮件已经“发”到了你的本地邮箱。
     >
     >   ```bash
     >   cat /var/mail/$USER
     >   # 或者
     >   cat /var/spool/mail/$USER
     >   ```

3. **权限问题**：

   - 通常，系统管理员（root）可以使用 `at`。
   - 普通用户能否使用，由系统文件 `/etc/at.allow` 和 `/etc/at.deny` 决定。一般情况下，所有用户都可以用。

4. **服务必须运行**：

   - `at` 命令依赖后台服务 `atd`。在 Ubuntu 上，通常默认安装并启动。如果不行，可以用 `sudo systemctl start atd` 启动它。

## xargs

**作用 ：将标准输入（stdin）的内容转换为命令行参数，传递给其他命令使用。** 

**示例**

```shell
echo "file1 file2 file3" | xargs rm
#相当于
rm file1 file2 file3
```

### 基本语法

```shell
command | xargs [选项] 新命令
```

- `command`：产生输出的命令（如 `find`、`ls`）
- `新命令`：你想执行的命令（如 `rm`、`cp`）

| 选项   | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| `-n N` | 每次最多传 N 个参数                                          |
| `-p`   | 执行前询问确认                                               |
| `-t`   | 显示要执行的命令                                             |
| `-0`   | 输入以空字符分隔（适合含空格路径,例如：告诉xargs 文件路径有空格，要保证不会按照空格分割路径再操作，要按照完整的路径操作） |
| `-I{}` | 替换模式，用于自定义插入位置                                 |

#### 替换模式 `-I{}` 使用示例

**{} 是占位符，表示每次替换一个参数进去**

```shell
echo file1 file2 | xargs -I{} cp {} /backup/
#等价于
cp file1 /backup/
cp file2 /backup/
```

## 定位端口和文件

### lsof(list open files)

​	用于列出当前系统中被进程打开的所有文件 。在类 Unix 系统（包括 Ubuntu）中，一切皆文件，不仅普通文件、目录，还包括网络套接字、设备文件等都被视为文件。

**有时候普通用户看不到系统级的进程，需要使用`sudo lsof [选项]`进行操作**

**常用命令**

- **`lsof <filename>`** 查找特定文件的进程

- **`-i :port`**  查找特定端口的进程
- **`-P`**  禁止将端口号转换为服务名称
  - 在网络排查场景中，如果想更直观明确地看到实际使用的端口号，避免因服务名转换造成干扰，使用`P`参数能让输出更符合需求。特别是在自定义端口或者对端口与服务对应关系不确定时，它有助于准确判断端口使用情况 。 
- **`-p <PID>`** 查找特定进程打开的文件
- **`-u <username> `** 查找特定用户打开的文件

**用于列出当前系统打开的文件**

```shell
#直接运行lsof，它会显示系统中所有进程打开的文件，输出信息包括进程 ID（PID）、进程所属用户、打开文件的类型等
COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
systemd     1 root  cwd    DIR    8,1     4096    2 /
systemd     1 root  rtd    DIR    8,1     4096    2 /
systemd     1 root  txt    REG    8,1   161144 1172 /lib/systemd/systemd

#FD（文件描述符）含义：常见的有cwd（当前工作目录）、txt（程序代码，即执行文件）、mem（内存映射文件）等。
```

##### 使用场景

- **排查文件被占用问题** **`lsof 文件名`**
  - 当你尝试删除某个文件，系统提示文件正在使用无法删除时，`lsof 文件名`就能找出是哪些进程在占用该文件。比如要删除`/tmp/lockfile`，但提示被占用，运行`lsof /tmp/lockfile`，就可看到占用进程信息，之后合理处理进程（如安全终止进程），就能删除文件。
- **诊断网络连接问题 `ls -i :80`**
  - 通过`lsof -i`可列出所有网络连接相关的进程，包括使用的协议、端口等。例如排查某个端口被哪个进程占用，`lsof -i :80`能查看占用 80 端口的进程，这对解决端口冲突很有帮助，像部署 Web 服务时，若 80 端口被占，就能借此找到占用者。
  - **端口占用问题其实 ss工具也可以解决，但是呢，lsof 功能更宽泛，除了网络连接（端口相关），还能查看进程打开的各类文件，比如普通文件、目录、设备文件等。**
  - **技术建议**
    - 当仅关注端口占用情况，特别是快速获取网络套接字信息时，`ss`是个不错选择。
    - 若在排查端口占用同时，还想了解进程对其他文件的操作，或进一步追踪进程行为，`lsof`会更合适。实际使用中，可根据具体需求灵活搭配这两个命令 。
- **追踪进程行为 `lsof -p PID`**
  - `lsof -p PID`查看特定进程打开的文件，了解其在做什么。比如怀疑某个进程异常读写文件，用此命令可查看该进程访问的文件路径、操作类型等，有助于分析进程是否存在恶意或错误行为。

##### 疑问：ss 显示的进程与lsof显示出的进程的疑义

###### 查看角度不同

- **`ss`**：它主要聚焦于网络套接字层面。当一个进程使用端口进行网络通信时，`ss`会明确显示占用该端口用于网络连接的进程。
  - 比如一个 Web 服务器进程通过 80 端口监听 HTTP 请求，`ss`就会显示这个 Web 服务器进程占用 80 端口。
- **`lsof`**：`lsof`从更宽泛的 “打开文件” 角度出发。除了网络套接字（这也是一种文件描述符类型），进程在运行过程中还会打开各种其他文件，如配置文件、日志文件等。
  - 例如，Web 服务器进程除了打开 80 端口对应的套接字文件用于网络通信，还可能打开了多个配置文件、日志文件等。`lsof`会将进程打开的所有这些文件都列出来，所以看上去进程相关的条目更多。

###### 父子进程与资源共享

- 有些进程启动后会创建子进程，并且父子进程可能共享一些资源，包括网络端口。`ss`可能只显示负责监听端口的主进程。而`lsof`会显示所有相关进程，包括子进程及其打开的文件，因为子进程也在使用与端口相关的资源，这就导致`lsof`查到的进程数量多于`ss`。

## 估算文件或目录所占用的磁盘空间

**估算文件或目录所占用的磁盘空间，磁盘报警和不够用时可以进行查看**

### df

`df -h` #以人类可观的形式查看系统磁盘空间

### du

默认是当前目录所占用的磁盘容量

- **-s**  查看总的占用情况，文件夹不显示
- **-h（human read 人类友好阅读）**
- **-d n 指定深度(n层目录)，当前目录下第一层到第n层的占比都显示出来**
  - 或者使用`--max-depth=n`
- **-a **表示 “all”，即不仅显示读的大小，还会显示指定目录下所有文件的大小。

可以根据不同的情况进行选项的结合，下面是一下结合的例子

```shell
#在想快速了解某个目录整体占用空间且希望以易读格式呈现时使用
du -sh /home #能直观看到/home目录总共占用多少磁盘空间，输出类似50G /home

#-h与-a（显示文件）结合：当不仅要知道目录占用空间，还需了解目录内每个文件占用空间大小时使用。
du -ha /etc #可查看/etc目录下所有文件和子目录的占用空间，以人类可读格式显示，便于详细分析哪些文件占用空间较多 。

#想查看/var目录下一级子目录及文件占用空间
du -ha --max-depth=1 /var

#-s与--exclude结合：若要汇总某个目录占用空间，但想排除特定子目录或文件类型时使用。例如想统计/data目录占用空间但排除/data/temp子目录，执行
du -s --exclude=/data/temp /data
```

#### 结合sort命令

`sort`命令用于对文本文件的行进行排序

**基本语法**：`sort [选项] [文件名]`，若不指定文件名，`sort`会从标准输入读取数据。

> -n 按数字大小排序 默认是升序
>
> -r 反向排序 降序
>
> - **`-k`**：指定排序字段。当文本有多列时很有用。例如有文件`students.txt`内容为 “Alice 20\nBob 18\nCharlie 22”，想按年龄（第二列数字）排序，执行`sort -n -k 2 students.txt`，输出为 “Bob 18\nAlice 20\nCharlie 22” 。
> - **`-f`**：忽略大小写，将大写和小写视为相同，比如 “a” 和 “A” 会同等对待进行排序。
> - **`-h`**选项能让`sort`理解人类可读的数字格式（如`K`、`M`、`G`等）并按数值排序 

​	直接使用`sort`命令对文件排序，它会按字符编码顺序进行排序，不论是纯字母还是数字文本或者是混合文本，会比较首个字母或数字的编码进行比较

##### 结合使用案例

**`-h`选项让`sort`命令启用了专门的解析逻辑。这个选项使`sort`能识别常见的单位后缀（`K`、`M`、`G`等），并将其换算成实际数值进行比较。**

```shell
#按文件大小降序排列
du -ah | sort -rh
#解释：du -ah以人类可读格式（-h）列出当前目录下所有文件和目录（-a）的磁盘占用空间。然后通过管道（|）将这些输出传递给sort -rh，sort命令以人类可读格式（-h）反向（-r）排序，这样就可以从大到小看到各个文件和目录的空间占用，快速定位占用空间最大的对象。
#只查看目录且按大小降序排列：
du -sh */ | sort -rh
#解释：du -sh */以人类可读格式（-h）只显示当前目录下各个子目录（*/）的总占用空间（-s）。再用sort -rh将结果按从大到小排序，有助于快速找出占用空间大的子目录。


#查询占用磁盘最大的五个文件夹及其占用情况
sudo du -h -d 1|sort -rh | head -n 5
```

### find

```shell
find [搜索路径] [匹配条件] [操作]
```

`	find` 命令在 Linux 中用于在文件系统中搜索文件和目录，功能强大且灵活。以下是一些常用的选项及其组合示例：

**还有按类型`-type`和按大小`-size`来搜索,就不一一举例了**

#### 按名称搜索

- **选项**：
  - `-name "pattern"`：按文件名匹配，支持通配符。
  
    ```shell
    find -name "*.*" //查询所有文件
    ```
  
  - `-iname "pattern"`：忽略大小写匹配文件名。

#### 按时间搜索

- **选项**：-mmin 是属于分钟
  
  - `-mtime n`：搜索 n 天前修改过的文件。**正好在 n 天前，在某一天**
  - `-mtime +n`：搜索超过 n 天前修改过的文件。**早于 n 天前	&lt; n天前，不包括那天**
  - `-mtime -n`：搜索 n 天内修改过的文件。**晚于 n 天前（即 n 天内）	&gt; n天前到现在的时间**
  - `-atime`、`-ctime`：类似 `-mtime`，但分别表示访问时间和状态更改时间。
  
    **拓展**
  
    - `-ctime`：修改权限、所有者、软链接、重命名、修改内容等
    - `-atime`：`cat`,`less`,`grep`, 程序读取文件等
    - `-mtime`：编辑文件内容、用程序修改内容等

#### 按权限搜索

- **选项**：
  - `-perm mode`：搜索权限完全匹配的文件
  
    ```shell
    # 查找权限恰好为 644 (rw-r--r--) 的文件
    find /home -perm 644
    
    # 查找权限恰好为 755 (rwxr-xr-x) 的目录
    find /etc -type d -perm 755
    
    # 查找权限恰好为 777 (rwxrwxrwx) 的所有文件（危险权限！）
    find /tmp -perm 777
    ```
  - **任何权限位匹配（八进制模式前的 `/` 或 `+`）**
  
    搜索**至少包含**指定权限位的文件（已弃用 `+`，推荐使用 `/`）。
  
    **语法：** `-perm /mode`
  
    ```bash
    # 查找任何用户有写权限的文件（危险！）
    find / -type f -perm /222
    
    # 查找有 setuid 位 set 的文件（通常为 4000 或 6000 等）
    find /usr/bin -perm /4000
    
    # 查找组用户有执行权限的文件
    find /home -perm /010
    ```
  - **全部权限位匹配（八进制模式前的 `-`）**
  
    搜索**包含全部**指定权限位的文件（权限必须包含 mode 中的所有位）。
  
    **语法：** `-perm -mode`
  
    ```bash
    # 查找用户有读、写、执行权限的文件（即至少是 700 权限）
    find /bin -perm -700
    
    # 查找其他用户有写权限的文件（危险权限！）
    find /home -perm -002
    
    # 查找 setgid 位 set 且组有写权限的目录
    find / -type d -perm -2002
    
    # 查找用户有读写执行，组有读执行，其他有读权限的文件
    find /usr -perm u=rwx,g=rx,o=r
    
    # 查找组用户有写权限的文件
    find /var -perm g=w
    
    # 查找其他用户有执行权限的脚本
    find ~ -name "*.sh" -perm o=x
    ```
  
    

#### 对搜索结果执行操作

- **选项**：
  - `-exec command {} \;`：对搜索结果执行指定命令，`{}` 代表找到的文件。
  - `-ok command {} \;`：与 `-exec` 类似，但执行前会询问用户确认。

```bash
# 查找并删除当前目录下所有的临时文件（扩展名为 .tmp）
find . -name "*.tmp" -exec rm {} \;

# 查找 /tmp 目录下所有超过 7 天的文件，并询问用户是否删除
find /tmp -mtime +7 -ok rm {} \;
```

### IO读写状态

#### **iotop（实时监控进程级 I/O）**

```shell
# 安装
sudo apt-get install iotop  # Ubuntu/Debian
sudo yum install iotop      # CentOS/RHEL

# 实时显示进程的 I/O 读写情况（需 root 权限）
sudo iotop
```

- 只显示正在进行 I/O 的进程。
- `P`：按 I/O 吞吐量排序。
- `q`：退出。

## 网络连接状况

**端口占用，网络连接等等**

### ss

`ss` 是 `netstat` 的现代替代品，速度更快，占用更少资源，并提供更多功能。

#### 常用

```shell
#缺少 -a 选项，它只显示处于监听状态的 TCP、UDP 套接字
ss -tulnp
#ss -atunp 中的 -a 选项表示 “all”，它会显示所有套接字（socket），包括处于监听（listening）状态和非监听状态的套接字。
ss -atulnp
#查看已建立的网络连接，grep ESTAB：仅显示已建立连接（ESTAB 是 ESTABLISHED 的缩写）。
ss -tan | grep ESTAB
```

其他的选项和netstat一样（意义也一样）

除了输出结果不一样，**ss** 工具输出的**信息过于冗杂**，**字段名偏技术化**

**信息过于冗杂：**

- 默认情况下，`ss -a` 会显示 `nl`、`tcp`、`udp`、`raw` 等所有协议的信息，初学者可能会被这些 Netlink 信息搞混。

**字段名偏技术化：**

- `Netid` 这样的字段名称，更符合内核开发者的习惯，不够直观。
- `ss` 强调的是套接字（socket）状态，而不是传统的 TCP/UDP 连接状态。

### netstat

​	`netstat` 是一个较早期的网络连接监控工具，它能够显示网络连接、路由表、接口统计、伪装连接（masquerade connections）等信息。

#### 常用

```shell
netstat -tulnp

#查看已建立的网络连接
netstat -ant | grep ESTABLISHED
```

**常用命令选项**

- **`-a`**  查看所有的网络连接

- `-t -u` 查看tcp、udp连接

- `-l` 监听端口的状态，当此选项出现，所有东西都聚焦在监听的方面

  > ​	它主要关注的是本地系统哪些端口处于监听，等待外部连接的状态。
  >
  > ​	此时还没有实际的连接建立，也就不存在特定的远程网络 IP 地址与之相连，所以显示为 `0.0.0.0` 来表示监听所有接口，而不是具体的连接 IP 。
  >
  > ​	这种显示方式有助于系统管理员快速了解本地开启了哪些服务在等待连接，比如确认是否有异常端口监听，排查潜在安全风险。
  >
  > ​	如果想要查看已经建立连接的远程 IP 地址，就需要去掉 `-l` 选项，使用类似 `netstat -n` 的命令，它会展示所有网络连接状态，包括已连接的远程 IP 及端口信息 。

- **`-n`** 以数字格式显示ip地址和端口

- **`-p`** 显示PID和程序名称

#### **`-r`** 查看路由表

```shell
ubuntu22@ubuntu22:~$ netstat -r
Kernel IP routing table
Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
default         xiaoqiang       0.0.0.0         UG        0 0          0 ens33
192.168.31.0    0.0.0.0         255.255.255.0   U         0 0          0 ens33
xiaoqiang       0.0.0.0         255.255.255.255 UH        0 0          0 ens33
```

**可以得到下面这些信息**

​	路由表就像是电脑的“导航地图”，告诉电脑如何把数据包送到不同的目的地（比如访问网页、发送邮件等）。这个表会列出网络的路径规则。

​	显示了 Ubuntu 系统当前的 **Kernel IP routing table**（内核 IP 路由表），也就是系统用来决定数据包去哪里的规则。

##### 输出内容结构

##### 逐行分析路由表

###### 第一行

**意思**：这是**默认路由**。当你的电脑不知道数据包该去哪里时（比如访问一个不在本地网络的网站，比如 google.com），它会把数据包送到网关 xiaoqiang。

- **Gateway: xiaoqiang**：xiaoqiang 可能是你的路由器（比如小米路由器的默认名称）。它负责把你的数据包转发到外网。

- **Genmask: 0.0.0.0**：表示这条规则适用于“所有地址”（因为是默认路由）。

- **Flags: UG**：U 表示路由有效，G 表示需要通过网关。

- **Iface: ens33**：数据包会通过你的网卡 ens33 发送到 xiaoqiang。

**通俗解释**：就像你寄快递，如果不知道具体送到哪，就先送到快递站（xiaoqiang），它会帮你转发到正确的地址。

###### 第二行

**意思**：这是你的**本地网络**的路由规则。192.168.31.0 是一个网络段，表示你的局域网（LAN）内的所有 IP 地址（比如 192.168.31.1 到 192.168.31.255）。

- **Gateway: 0.0.0.0**：没有网关，意味着这些地址是直接连接的（都在同一个局域网内，比如你的电脑、路由器、打印机等）。

- **Genmask: 255.255.255.0**：子网掩码表示这个网络段有 256 个地址（192.168.31.0 到 192.168.31.255）。

- **Flags: U**：路由有效，不需要网关。

- **Iface: ens33**：数据包通过网卡 ens33 直接发送到局域网内的设备。

**通俗解释**：如果你要跟同一个 Wi-Fi 下的其他设备（比如手机、另一台电脑）通信，数据直接通过网卡发送，不需要经过路由器。

###### 第三行

**意思**：这是指向一个具体主机的路由规则，xiaoqiang 是你的路由器（可能它的 IP 是 192.168.31.1）。

- **Gateway: 0.0.0.0**：没有网关，因为你的电脑和 xiaoqiang 在同一个网络，直接通信。

- **Genmask: 255.255.255.255**：子网掩码表示这是一个单一的 IP 地址（只针对 xiaoqiang 这个设备）。

- **Flags: UH**：U 表示路由有效，H 表示目标是一个具体的主机（Host）。

- **Iface: ens33**：通过网卡 ens33 直接访问 xiaoqiang。

**通俗解释**：如果你要登录路由器的管理页面（比如在浏览器输入 192.168.31.1），数据会直接通过网卡送到路由器。

**这个路由表告诉我们什么？**

通过这三条规则，我们可以知道：

1. **本地网络通信**：你的电脑在局域网（192.168.31.0/24）内可以直接和其他设备通信，比如访问路由器、打印机等。
2. **访问外网**：如果要访问外部网络（比如上网），数据会通过网卡 ens33 送到路由器 xiaoqiang，然后由路由器转发到互联网。
3. **路由器通信**：你的电脑和路由器 xiaoqiang 是直接连接的，可以直接访问它的管理页面。

### `ss`and`netstat`区别

| **对比点**   | **`netstat`**                         | **`ss`**                                |
| ------------ | ------------------------------------- | --------------------------------------- |
| **显示格式** | 传统格式，字段较为固定。              | 更现代化，字段更详细、更灵活。          |
| **进程信息** | PID/Program name 一列显示。           | 进程信息放在 `users:(("process"))` 中。 |
| **协议字段** | `Proto` 显示协议名称。                | `Netid` 显示协议类型，支持更多协议。    |
| **状态字段** | `State` 显示 TCP 状态。               | `State` 支持更多状态，如 `UNCONN`。     |
| **性能**     | 依赖 `/proc/net` 文件系统，速度较慢。 | 直接从内核获取数据，速度更快。          |
| **维护状态** | 已停止维护。                          | 持续维护、推荐使用。                    |

#### **`netstat -a` 会比 `ss -a` 更直观**

`netstat` 和 `ss` 的设计初衷就有所不同：

- **`netstat`：** 传统工具，输出格式简单，关注 TCP/UDP 套接字，常用于快速查看网络连接。
  - 只显示 **TCP/UDP 连接**，避免了过多的 Netlink 信息干扰。

- **`ss`：** 现代化工具，信息更丰富、更详细，支持更多协议（如 Netlink、SCTP、RAW）。
  - Netlink 信息：

    - `ss -a` 会显示 `nl`（Netlink）套接字，这些套接字是内核模块通信用的，一般用户很少关注。


##### 总结及拓展

> **关于工具查询时显现出来的有关 unix 的信息**
>
> UNIX 域套接字是一种进程间通信（IPC）机制，主要用于同一台 UNIX 或类 UNIX 系统（如 Ubuntu）主机上的进程之间进行通信。
>
> 与网络套接字（如 TCP、UDP 套接字）不同，UNIX 域套接字不依赖网络协议栈和网络地址。它基于文件系统路径来标识通信端点，在同一主机内通信效率更高，且安全性更好，因为它不会像网络套接字那样暴露在网络中，减少了网络攻击风险。

**现代系统（RHEL7+/Ubuntu 16.04+）:**

- 推荐全面切换到 `ss`，其输出信息更详尽，支持更多协议。

**兼容性需求（CentOS6/RHEL6 及以下）:**

- `netstat` 依旧可用，但部分选项（如 `-r`）已过时。

**调试排查：**

- 优先使用 `ss`，结合 `grep` 和 `awk` 进行数据过滤和统计。

`tcpdump` 是 Linux 系统中一个非常强大的**网络抓包工具**，用于捕获和分析通过网络接口传输的数据包。它可以帮助你排查网络问题、分析流量行为、调试协议通信等。

---

## tcpdump 基本用法

### 安装 tcpdump（如果未安装）

```bash
# Debian/Ubuntu
sudo apt update && sudo apt install tcpdump

# CentOS/RHEL
sudo yum install tcpdump

# Fedora
sudo dnf install tcpdump
```

---

### 最基本的使用方式

```bash
sudo tcpdump
```

- 默认会监听第一个网络接口（如 `eth0` 或 `enp0s3`）上的所有数据包。
- 按下 `Ctrl+C` 停止抓包。

---

#### 输出示例（每行代表一个数据包）

```
14:25:36.789012 IP 192.168.1.5.56789 > 8.8.8.8.53: UDP, length 40
```

解释：

| 字段                | 含义                                    |
| ------------------- | --------------------------------------- |
| `14:25:36.789012`   | 时间戳                                  |
| `IP`                | 协议类型（还可以是 ARP、IPv6、ICMP 等） |
| `192.168.1.5.56789` | 源 IP 地址 + 端口号                     |
| `>`                 | 数据流向                                |
| `8.8.8.8.53`        | 目标 IP 地址 + 端口号                   |
| `UDP, length 40`    | 协议类型与数据长度                      |

---

###  常用选项详解

| 选项                | 功能说明                                    | 示例                              |
| ------------------- | ------------------------------------------- | --------------------------------- |
| `-i <interface>`    | 指定网络接口                                | `sudo tcpdump -i eth0`            |
| `-nn`               | 不解析主机名和端口名（显示 IP 和端口号）    | `sudo tcpdump -nn`                |
| `-c <count>`        | 抓取指定数量的数据包后退出                  | `sudo tcpdump -c 5`               |
| `-w <file>`         | 将数据包写入文件（**保存为 pcap 格式**）    | `sudo tcpdump -w capture.pcap`    |
| `-r <file>`         | **读取已保存的 pcap 文件进行分析**          | `sudo tcpdump -r capture.pcap`    |
| `-v`, `-vv`, `-vvv` | 显示详细信息级别                            | `sudo tcpdump -vvv`               |
| `-s snaplen`        | 设置快照长度（默认只捕获前 262 字节）       | `sudo tcpdump -s 0`（捕获完整包） |
| `-X`                | 以十六进制和 ASCII 形式显示数据包内容       | `sudo tcpdump -X`                 |
| `-A`                | 以 ASCII 形式显示数据包内容（适合查看文本） | `sudo tcpdump -A`                 |

---

### 过滤器语法（Filter）

`tcpdump` 支持使用 **表达式（expression）** 来过滤数据包。

**多条件组合注意使用 and 或者其他**

### 常见表达式示例：

| 表达式                           | 含义                                          |
| -------------------------------- | --------------------------------------------- |
| `port 80`                        | 只捕获端口 80 的流量（HTTP）                  |
| `src host 192.168.1.100`         | 只捕获源地址为 192.168.1.100 的数据包         |
| `dst port 22`                    | 只捕获目标端口是 22 的数据包（SSH）           |
| `host 192.168.1.100`             | 捕获源或目标地址为 192.168.1.100 的所有数据包 |
| `tcp` / `udp` / `icmp`           | 协议过滤                                      |
| `src net 192.168.1.0/24`         | 源网段过滤                                    |
| `not port 22`                    | 排除 22 端口                                  |
| `port 80 and host 192.168.1.100` | 多条件组合                                    |

#### 示例：

eth0:网卡接口

```bash
sudo tcpdump -i eth0 port 80 -nn
sudo tcpdump -i eth0 src host 192.168.1.100 and dst port 53
sudo tcpdump -i eth0 tcp port 22 -w ssh_traffic.pcap
```

---

### 实用技巧

#### 查看 HTTP 请求头（明文）

```bash
sudo tcpdump -i eth0 -nn port 80 -A | grep -i "GET\|POST\|Host:"
```

#### 抓包并实时查看

```bash
sudo tcpdump -i eth0 -nn -A port 80
```

#### 使用 Wireshark 分析 pcap 文件
你可以将抓包结果保存为 `.pcap` 文件，然后在图形化工具 [Wireshark](https://www.wireshark.org/) 中打开分析。

```bash
sudo tcpdump -i eth0 -w my_capture.pcap
```

---

##### 注意事项

- 需要 root 权限才能监听网络接口：使用 `sudo`。
- 在高流量环境中抓包可能导致性能下降。
- 抓包时建议使用 `-w` 参数保存到文件，避免终端刷屏。
- 抓包文件可能包含敏感信息，请注意隐私保护。

---

#####  总结

| 用途               | 命令示例                               |
| ------------------ | -------------------------------------- |
| 抓包并显示         | `sudo tcpdump -i eth0 -nn`             |
| 抓包保存到文件     | `sudo tcpdump -i eth0 -w capture.pcap` |
| 抓包并过滤特定端口 | `sudo tcpdump -i eth0 port 80 -nn`     |
| 抓包并过滤 IP      | `sudo tcpdump host 192.168.1.100`      |
| 读取 pcap 文件     | `sudo tcpdump -r capture.pcap`         |

## top

**实用的系统监控工具**

它能实时显示系统中各个进程的资源占用情况，比如 CPU 使用率、内存使用量等

### htop工具

**htop是增强版的top工具，显示更直观**

- **功能特性也强大**

  ```shell
  F1（Help）：按下 F1 会弹出帮助菜单，详细列出所有快捷键及功能说明，新手可借此快速熟悉操作。
  F2（Setup）：
  	进入设置界面，在此可自定义 htop 显示内容，如选择要展示的进程字段、调整界面颜色方案、设置排序规则等。例如，若想突出显示内存占用高的进程，可在此设置按内存使用率排序。
  F3（Search）：
  用于在进程列表中搜索特定进程。当系统中进程众多，想快速定位某个进程时，按 F3 输入进程名或部分关键字，就能快速找到目标进程。
  F4（Filter）：
  可对进程列表进行过滤。比如只希望看到属于某个特定用户的进程，按 F4 输入用户名，列表就只显示该用户相关进程，方便排查特定用户相关问题。
  F5（Tree）：
  以进程树形式展示进程，直观呈现进程间父子关系。对于理解复杂系统服务架构或排查因进程关联导致的问题很有帮助。例如查看某个大型应用及其子进程运行情况。
  F6（Sort）：
  用于选择排序依据。可以按 CPU 使用率、内存使用率、PID 等多种参数对进程进行排序，快速找出资源占用高的进程。如按内存使用率排序，可轻松发现哪些进程消耗内存最多。
  F7/F8：
  在设置了排序规则后，F7 可降低进程优先级（增大 Nice 值），F8 则提高进程优先级（降低 Nice 值）。适用于调整进程资源分配，比如降低不重要进程优先级，让重要进程优先获取资源。
  F9（Kill）：
  选中进程后按 F9 弹出操作菜单，可选择发送不同信号给进程，如常用的 SIGTERM（正常终止进程）、SIGKILL（强制终止进程）。当进程出现无响应等异常情况，可尝试用此终止进程。
  F10（Quit）：退出 htop 程序，返回终端命令行界面。
  ```

### top界面显示快捷键

按下`top`之后

- **按下大写字母`E`,**上面的一段数据比较可观(比如MB会变成GB)
- **按下小写字母e**，下面的一段动态数据会变得可观

- **指定更新时间 `-d seconds`**
  - **状态默认3秒更新一次,可以指定时间**

- **指定某个用户**
  - `u 回车 username 回车`

- **排序相关**
  - **`P`**：按 CPU 使用率对进程进行排序，能快速定位占用 CPU 资源高的进程。
  - **`M`**：按内存使用率对进程排序，方便找出吃内存大户。
- **进程操作相关**
  - **`k`**：用于终止进程。按下后需输入要终止进程的 PID（进程标识符） 及信号值（一般默认 15，即温和终止； 9 强制删除）。
- **显示调整相关**
  - **`f`**：进入列选择界面，可通过它来选择要在 `top` 中显示的列信息，如进程的用户、虚拟内存等。选好后按回车键确认。
  - **`z`**：切换 `top` 界面的颜色显示模式，方便在不同环境下查看。
  - **`l`**：切换是否显示系统负载信息。若想专注查看进程，可隐藏负载信息节省空间。

### 系统信息概况

#### 第一部分

- **第一行**：类似 “`top - 15:30:12 up 1 day, 23:45, 2 users, load average: 0.10, 0.20, 0.30`”

  - **时间**：“`15:30:12`” 显示当前系统时间。
  - **运行时间**：“`up 1 day, 23:45`” 表明系统已经连续运行了 1 天 23 小时 45 分钟。
  - **用户数**：“`2 users`” 指当前有 2 个用户登录系统。
  - **系统负载**：“`load average: 0.10, 0.20, 0.30`”，三个数值分别表示过去 1 分钟、5 分钟、15 分钟内的系统平均负载。一般认为，单核 CPU 负载在 1 以下比较正常；多核 CPU，负载数值除以核心数，结果在 1 以下较理想。

- **第二行**：如 “`Tasks: 200 total, 1 running, 199 sleeping, 0 stopped, 0 zombie`”

  - **总任务数**：“`200 total`” 代表系统当前的总进程数为 200 个。
  - **运行中进程数**：“`1 running`” 即正在运行的进程数量为 1 个。
  - **睡眠中进程数**：“`199 sleeping`” 表示处于睡眠状态（等待资源等）的进程数。
  - **停止的进程数**：“`0 stopped`” 说明当前没有停止的进程。
  - **僵尸进程数**：“`0 zombie`” 意味着不存在僵尸进程（子进程结束但父进程未回收其资源的进程）。

- **第三行**：像 “`%Cpu(s): 0.1 us, 0.1 sy, 0.0 ni, 99.8 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st`”

  - **用户空间 CPU 使用率**：“`0.1 us`” 指用户空间程序占用 CPU 的百分比。
  - **内核空间 CPU 使用率**：“`0.1 sy`” 代表内核空间（系统调用等）占用 CPU 的比例。
  - **改变过优先级的进程 CPU 使用率**：“`0.0 ni`” 表示改变过 nice 值（优先级）的进程占用 CPU 的情况。
  - **空闲 CPU 使用率**：“`99.8 id`” 是 CPU 空闲的比例。
  - **等待 I/O 的 CPU 使用率**：“`0.0 wa`” 说明因等待 I/O 操作而处于等待状态的 CPU 时间比例。
  - **硬中断 CPU 使用率**：“`0.0 hi`” 指处理硬中断所占用的 CPU 时间百分比。
  - **软中断 CPU 使用率**：“`0.0 si`” 表示处理软中断占用的 CPU 时间比例。
  - **被虚拟机偷走的 CPU 使用率**：“`0.0 st`”，在虚拟机环境下，此值表示被虚拟机管理程序偷走的 CPU 时间百分比。

- **第四行和第五行**：以 “`KiB Mem : 8169372 total, 111111 free, 2222222 used, 5836039 buff/cache`” 和 “`KiB Swap: 2097148 total, 2097148 free, 0 used. 5836039 avail Mem`” 为例

  - **第四行物理内存，第五行交换空间**

  - **物理内存**

    - **总量**：“`8169372 total`” 是系统物理内存的总量，单位是 KiB。

    - **空闲量**：“`111111 free`” 为当前空闲的物理内存大小。

    - **已用量**：“`2222222 used`” 指已经被使用的物理内存。

    - **缓存 / 缓冲区**：“`5836039 buff/cache`” 表示用作缓存和缓冲区的

      > 这部分内存用于缓存和缓冲区。缓冲区主要用于存储尚未写入磁盘的数据，缓存则用于存储从磁盘读取的数据，方便后续快速访问。“`5836039 buff/cache`” 表明系统分配了这么多物理内存用于此类缓存和缓冲功能，它有助于提高 I/O 性能。

      - **avail Mem**：这个数值表示系统当前可用于运行新程序的内存量，它综合考虑了物理内存的空闲部分以及可回收的缓存和缓冲区内存，是衡量系统当前可用内存资源的一个重要指标。

#### 第二部分

**展示几个字段**

- **PR**：进程优先级（Priority），反映内核调度程序对进程的调度优先级，数值越低优先级越高，内核会优先调度。一般系统自动调整，但也可手动改变。
- **NI**：Nice 值，它用于调整进程的优先级，取值范围 -20（最高优先级）到 19（最低优先级）。普通用户只能增大 Nice 值（降低优先级），root 用户可随意调整。NI 值会影响 PR 值，进而影响进程调度。
- **VIRT**：虚拟内存大小（Virtual Memory），单位通常是 KiB。指进程所使用的虚拟内存总量，包括进程代码、数据、共享库以及申请但未实际使用的内存。它反映了进程理论上可使用的内存空间，并非实际占用物理内存。
- **RES**：常驻内存大小（Resident Memory），单位 KiB。即进程当前实际占用的物理内存大小，这部分内存是进程运行时真正占用且不会被换出到磁盘交换空间的。
- **SHR**：共享内存大小（Shared Memory），单位 KiB。表示进程使用的共享内存大小，比如与其他进程共享的库文件所占用的内存。
- **S**：进程状态（State），常见状态有：
  - **R（Running）**：正在运行或在运行队列中等待 CPU 资源。
  - **S（Sleeping）**：睡眠状态，进程在等待资源，如等待 I/O 完成或信号，可被唤醒。
  - **D（Disk Sleep）**：不可中断睡眠状态，通常是进程在等待磁盘 I/O 操作完成，此时无法通过信号终止进程。
  - **T（Stopped）**：进程被暂停，如通过调试器暂停进程。
  - **Z（Zombie）**：僵尸进程，子进程已结束运行，但父进程未回收其资源，这种进程实际已死亡，只占用少量系统资源，需处理避免资源浪费。
- **%CPU**：进程占用 CPU 的百分比，反映该进程在一段时间内使用 CPU 资源的比例。数值越高，说明进程对 CPU 资源需求越大。
- **%MEM**：进程占用物理内存的百分比，即该进程的 RES 大小占系统总物理内存的比例，体现进程对内存的占用程度。
- **TIME+**：进程累计使用 CPU 的时间，格式为 `hh:mm:ss.cc`，精确到百分之一秒，直观展示进程自启动以来消耗 CPU 资源的时长。
- **COMMAND**：启动进程的命令，显示进程对应的可执行文件名称及启动参数，通过它能快速了解进程的功能及启动方式。

## ps

- **只是一个快照只显示执行的那一刻，三种不同的显示风格**

  - **Unix 风格**：选项带 `-` （如 `ps -ef`）

    **BSD 风格**：选项不带 `-` （如 `ps aux`）

    **GNU 风格**：长选项 `--`（如 `ps --forest`）
  
- **所谓不属于终端和有终端的区别在于，前台执行和后台执行得区别**

​	每个进程都可能以两种方式存在。前台与后台，所谓前台进程就是用户目前的屏幕上可以操作的。后台进程则是实际在操作，由于屏幕上无法看到的进程，通常时候后台方式执行。

​	一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中，直到关机才结束 (ps -aux 中的 x 选项会显示)

**用于查看当前运行的进程**

​	在排查系统性能问题或想了解系统中正在运行的程序时，熟练运用`ps`能够和获取关键信息

### 输出注意事项

​	**因为 ps -aux 命令会显示系统中所有当前活跃的进程，包括执行 ps 命令那一刻正在运行的进程。由于 grep 进程在处理管道数据时仍然处于活动状态，因此会被 ps 捕捉到并显示在结果中。** 

**如何避免 grep 进程出现在结果中？** 

​	**为了避免 grep 自身的进程干扰搜索结果，可以使用以下方法： 排除自身进程： ps -aux | grep [某]个字符 在 grep 的搜索模式中，将关键字的首字母放在方括号内，例如 [某]个字符。这样，grep 会匹配包含 "某个字符" 的行，但不会匹配自身命令行中的 "grep [某]个字符"。**

### 常用选项

- **-a(正常进程)**：**显示所有与终端相关的进程，包括其他用户的进程。这样可以看到不仅仅是自己当前终端会话下的进程，方便了解系统中各终端上活跃的进程。**
- **-u**：**以用户友好格式显示进程信息。重点展示与进程所有者相关的信息，像用户名（USER）、启动时间（START）、CPU 使用率（% CPU）、内存使用率（% MEM）等**
  - **-u username: 作用是仅显示指定 `username` 用户所拥有的进程信息 。比如系统管理员想查看特定用户 `testuser` 运行的进程，就可以执行 `ps -u testuser`，输出的进程列表仅包含 `testuser` 启动的进程，这对于多用户系统中，针对特定用户进程进行排查、资源监控等操作很有帮助。**
- **-x(守护进程，后台进行)**：显示没有控制终端的进程。有些后台服务进程可能并不依赖于终端，这个选项能让它们也显示出来，使进程查看更全面。
  - **一般来说，许多进程启动时会关联一个控制终端，比如你在终端里手动启动的程序，这个终端就是它的控制终端。但有些进程，像系统后台的守护进程（daemon），它们在系统启动时就自动运行，不需要与任何终端交互，也就没有控制终端。**
  - **在排查系统后台服务相关问题时，`-x`选项很关键。因为有些后台服务进程若出现故障，但由于没有控制终端，不容易被发现，通过`ps -x`相关组合命令，能确保这些进程都在你的监控范围内，及时发现潜在问题。**
- **-e**：**显示系统中所有进程，涵盖了系统启动以来运行的各个进程，不管其是否与终端相关。**
  - 主要解决的是进程范围的问题，确保所有正在运行的进程都被列出。
  - `-x`选项重点在于显示那些没有控制终端的进程。有些后台进程虽然没有控制终端，但可能与某个终端存在某种联系（比如通过环境变量等方式间接关联），这种情况下，仅用`-e`选项能列出它们，但`-x`选项更精准地强调了 “无控制终端” 这一特性。
- **-f**：**以完整格式显示进程信息。除了包含`u`选项的部分信息外，还会显示进程的用户 ID（UID）、父进程 ID（PPID）、CPU 使用率的累计值（C）等。**
- **`ps -c`**会列出进程的真实名称（comm 字段），而不是通常显示的可执行文件名。这有助于更准确地识别进程的本质，因为有些进程的可执行文件名可能被修改或隐藏真实用途，通过真实名称能更好地了解进程。
- **-C**：它后面通常跟进程名，比如`ps -C process_name`。这个选项用于仅显示指定进程名的进程信息。比如要查看名为`apache2`的进程状态，就可以用`ps -C apache2`，方便精准定位特定进程，而无需从众多进程信息中筛选。

#### 常用选项结合

- 如果你需要查看 **资源占用**（如 CPU、内存），用 ps -aux。

- 如果你需要查看 **进程关系**（如父进程）或 **完整命令**，用 ps -ef。

```shell
#一个用于查看系统所有进程详细信息的命令
	#比如排查进程依赖引发的故障、了解系统资源长期分配情况时，“ps -ef” 是非常得力的工具
ps -ef
#-e: 显示所有进程（包括系统进程和用户进程）。
#-f: 显示完整格式的输出（包括更多字段，如父进程 ID、启动时间等）。
#输出格式是 System V 风格，包含字段如 UID, PID, PPID, C, STIME, TTY, TIME, CMD。

#列出系统中所有正在运行的进程的详细信息
ps -aux
#-a: 显示所有用户的进程（不限于当前用户）。
#-u: 显示详细的用户信息（包括用户、CPU 使用率、内存使用率等）。
#-x: 显示没有控制终端的进程（如守护进程）。
#输出格式是 BSD 风格，包含字段如 USER, PID, %CPU, %MEM, VSZ, RSS, TTY, STAT, START, TIME, COMMAND。

#结合其他方面
#以树状结构显示进程关系，直观展示进程间的父子关系，对于理解复杂的进程层次结构很有帮助，特别是在一些服务启动多个子进程的情况下。
ps -aux --forest
#结合 grep 查找特定进程或结合 sort 按资源排序
ps -aux | grep nginx
ps -aux --sort=-%mem
#适合查看进程的父子关系（通过 PPID），或需要完整命令行参数时。
#常用于进程树查看（结合 pstree 或 grep
ps -ef |grep python
```

`-aux`和`-ef`**其中差异就是输出风格的差异**

### pstree

**能够更直观的莱卡进程信息**

**常用选项**

- `-p`:显示进程的PID
- `-u`:显示进程的所属用户

### kill 进程

基础选项

- `kill 进程号`
- `killall 进程名称`
  - 通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时有用
- `kill -9 进程号` 强制杀死进程

##### 示例

```shell
ps -ef | grep sshd

ubuntu22 3278  2451  0   0   6480 2324 pts/0    S+   08:00   0:00 grep --color=auto sshd
#为什么会出现这一行？
#这是因为你的命令 ps -aux | grep sshd 会 搜索所有包含 sshd 的进程，而 grep 自身的命令行参数中恰好包含 sshd，因此也会被匹配到。这是一个常见的 “假阳性” 问题。

#踢掉某个非法用户
kill 非法用户对应进程号
#终止远程登录服务sshd，在适当时候再次重启sshd服务
kill sshd对应的进程号
#终止多个gedit
killall gefit
#强制杀掉一个终端
kill -9 /bin/bash
```



## 服务管理工具

**systemctl**

​	**systemctl 是 Ubuntu（以及大多数现代 Linux 系统）中用于管理系统 服务（services） 和 系统状态（运行级别） 的工具。它是 systemd 系统和服务管理器的一部分。**

| 命令                                       | 作用                         |
| ------------------------------------------ | ---------------------------- |
| `systemctl start 服务名`                   | 启动某个服务                 |
| `systemctl stop 服务名`                    | 停止某个服务                 |
| `systemctl restart 服务名`                 | 重启某个服务                 |
| `systemctl status 服务名`                  | 查看服务的状态（是否运行）   |
| `systemctl enable 服务名`                  | 设置服务开机自启             |
| `systemctl disable 服务名`                 | 取消服务开机自启             |
| `systemctl is-enabled 服务名`              | 查看服务是否设置为开机自启   |
| `systemctl list-units --type=service`      | 列出当前正在运行的服务       |
| `systemctl list-unit-files --type=service` | 列出所有服务及其开机启动状态 |

#### 查看系统运行目标（运行模式）

Ubuntu 使用的是 systemd 的“目标单元（target）”代替传统的运行级别（runlevel）

```shell
# 查看当前默认的目标（相当于运行级别）
systemctl get-default
#输出可能是：
graphical.target（图形界面）
multi-user.target（多用户命令行）

# 设置图形界面模式（桌面版常用）
sudo systemctl set-default graphical.target

# 设置多用户命令行模式（服务器常用）
sudo systemctl set-default multi-user.target
```

​	这些命令是用来 **查看和设置系统的默认启动目标（target）** ，你可以把它理解为 Linux 的“运行模式”或“启动级别”。

​	在传统的 SysV init 系统中，Linux 有多个运行级别（runlevel）(传统有7个级别)

> ​	在 Ubuntu 中，并没有为 runlevel 2 做特殊配置。
>
> 📌 换句话说：Ubuntu 中 runlevel 2 实际上和 runlevel 3 是一样的。

​	而现代 Ubuntu 使用的是 `systemd` 系统，它不再使用数字表示运行级别，而是用所谓的 **"target"（目标单元）** 来代替。

##### target 是什么？它们保存在哪里？

这些 target 配置文件一般存放在：`usr/lib/systemd/system/`

**例如：**

- `/usr/lib/systemd/system/graphical.target`
- `/usr/lib/systemd/system/multi-user.target`

当你执行 `set-default` 命令时，实际上是在修改一个符号链接：

```shell
/etc/systemd/system/default.target
```

##### 如何临时切换目标而不重启？

如果你只是想临时切换运行模式，而不改变默认设置，可以用：

```shell
# 切换到图形界面
sudo systemctl isolate graphical.target

# 切换到命令行模式
sudo systemctl isolate multi-user.target
```

## cut 分割

​	在 Ubuntu 系统及其他 Linux 系统中，`cut` 是一个非常实用的文本处理命令，用于从文本文件或标准输入中提取指定的字段或字符。

​	`cut` 命令主要针对简单的文本提取需求，对于复杂的文本处理，可能需要结合 `awk`、`sed` 等其他工具

### 基本语法

```
cut [选项]... [文件]...
```

### 按字段提取

1. **指定分隔符**：默认情况下，`cut` 以制表符（`\t`）为分隔符来识别字段。但你可以使用 **`-d` 选项指定其他分隔符。**例如，对于以逗号分隔的文本行（如 `name,age,gender`），要提取 `age` 字段，可以这样：

```bash
echo "John,25,Male" | cut -d ',' -f 2
```

这里 `-d ','` 指定逗号为分隔符，**`-f 2` 表示提取第二个字段**。输出结果将是 `25`。

1. **提取多个字段**：可以通过 **`-f` 选项后跟字段编号列表来提取多个字段。**例如，要提取上述文本行中的 `name` 和 `gender` 字段：

```bash
echo "John,25,Male" | cut -d ',' -f 1,3
```

输出结果为 `John,Male`。你也可以使用范围来指定字段，如 `-f 1 - 3` 表示提取第 1 到第 3 个字段。

### 按字符提取

1. **提取指定字符范围**：使用 **`-c` 选项可以按字符位置提取文本。**例如，要提取字符串 `Hello World` 中的前 5 个字符：

```bash
echo "Hello World" | cut -c 1-5
```

输出结果为 `Hello`。如果只指定一个数字，如 `-c 3`，则提取该行的第 3 个字符。

### 应用场景

1. **数据处理**：在处理 CSV（逗号分隔值）文件时，`cut` 可轻松提取特定列的数据。例如，有一个包含用户信息的 `users.csv` 文件，每行格式为 `user_id,username,email`，要提取所有用户的 `email` 字段：

```bash
cut -d ',' -f 3 users.csv
```

1. **日志分析**：假设日志文件每行记录了时间、事件类型和详细描述，以空格分隔。要提取所有事件类型，可以：

```bash
cut -d ' ' -f 2 logfile.log
```



##  `seq` 命令简介

####  功能：
输出从起始值到结束值之间的一系列数字。

---

####  语法格式：

```bash
seq [选项] 尾数

seq [选项] 首数 尾数

seq [选项] 首数 步长 尾数
```
#####  示例 4：用空格分隔输出（默认是换行）
```bash
seq -s " " 1 5
```

输出：
```
1 2 3 4 5
```

---

#####  示例 5：生成带前导零的编号（适合文件排序）
```bash
seq -w 05
```

输出：
```
0
1
2
3
4
5
```

加上 `-w` 参数后会自动补零（如 `01`, `02`）。

##### 实际应用场景举例

##### 1. 批量创建文件
```bash
for i in $(seq 1 10); do touch file$i.txt; done
```

创建 `file1.txt` 到 `file10.txt`

---

##### 2. 循环执行命令 N 次
```bash
for i in $(seq 5); do echo "这是第 $i 次运行"; done
```

---

##### 3. 生成测试数据
```bash
seq 100 > numbers.txt
```

生成一个包含 1~100 的文本文件。

---

##### 常用参数说明

| 参数 | 含义                              |
| ---- | --------------------------------- |
| `-s` | 指定分隔符（默认是换行 `\n`）     |
| `-w` | 等宽输出（补零）                  |
| `-f` | 使用格式化字符串（类似 `printf`） |

##### 示例：使用格式化输出
```bash
seq -f "num%03g" 1 3
```

输出：
```
num001
num002
num003
```
